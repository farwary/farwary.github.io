{"meta":{"title":"Anivia","subtitle":"网站副标题","description":"网站描述","author":"wwwwjin","url":"https://wwwwjin.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2021-08-31T07:29:55.799Z","updated":"2021-08-31T07:29:55.799Z","comments":true,"path":"categories/index.html","permalink":"https://wwwwjin.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-31T07:45:59.377Z","updated":"2021-08-31T07:45:59.377Z","comments":true,"path":"tags/index.html","permalink":"https://wwwwjin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-01T02:35:34.071Z","updated":"2021-09-01T02:35:34.071Z","comments":false,"path":"about/index.html","permalink":"https://wwwwjin.github.io/about/index.html","excerpt":"","text":"与其互为人间 不如自成宇宙"}],"posts":[{"title":"Spring Boot","slug":"springboot/springboot-source/springboot-source-autoconfig","date":"2021-09-03T10:51:52.836Z","updated":"2021-09-05T04:08:04.158Z","comments":false,"path":"2021/09/03/springboot/springboot-source/springboot-source-autoconfig/","link":"","permalink":"https://wwwwjin.github.io/2021/09/03/springboot/springboot-source/springboot-source-autoconfig/","excerpt":"","text":"AutoConfigurationImportSelector 获取 META-INF/spring.factories 中 EnableAutoConfiguration.class 然后根据Conditional条件加载 DeferredImportSelectorHandler123456789101112131415public void process() &#123; List&lt;DeferredImportSelectorHolder&gt; deferredImports = this.deferredImportSelectors; this.deferredImportSelectors = null; try &#123; if (deferredImports != null) &#123; DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler(); deferredImports.sort(DEFERRED_IMPORT_COMPARATOR); deferredImports.forEach(handler::register); handler.processGroupImports(); &#125; &#125; finally &#123; this.deferredImportSelectors = new ArrayList&lt;&gt;(); &#125; &#125; DeferredImportSelectorGroupingHandler123456789101112131415161718192021222324252627282930313233public void register(DeferredImportSelectorHolder deferredImport) &#123; Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup(); DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent( (group != null ? group : deferredImport), key -&gt; new DeferredImportSelectorGrouping(createGroup(group))); grouping.add(deferredImport); this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getConfigurationClass()); &#125; public void processGroupImports() &#123; for (DeferredImportSelectorGrouping grouping : this.groupings.values()) &#123; //用于筛选的filter Predicate&lt;String&gt; exclusionFilter = grouping.getCandidateFilter(); grouping.getImports().forEach(entry -&gt; &#123; ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata()); try &#123; //导入自动装配需要的bean processImports(configurationClass, asSourceClass(configurationClass, exclusionFilter), Collections.singleton(asSourceClass(entry.getImportClassName(), exclusionFilter)), exclusionFilter, false); &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configurationClass.getMetadata().getClassName() + &quot;]&quot;, ex); &#125; &#125;); &#125; &#125; getImports1234567public Iterable&lt;Group.Entry&gt; getImports() &#123; for (DeferredImportSelectorHolder deferredImport : this.deferredImports) &#123; this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); &#125; return this.group.selectImports(); &#125; AutoConfigurationGroup1234567891011121314@Override public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123; Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); //获取自动配置 AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector) .getAutoConfigurationEntry(annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry); for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123; this.entries.putIfAbsent(importClassName, annotationMetadata); &#125; &#125; AutoConfigurationImportSelector123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; //排除项 AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取 META-INF/spring.factories 中 EnableAutoConfiguration.class // 获取 配置类 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 去重 configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); // 过滤 OnClassCondition OnWebApplicationCondition OnBeanCondition configurations = getConfigurationClassFilter().filter(configurations); // 通知 fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); &#125;protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; //EnableAutoConfiguration.class List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; &#125;@Override public Iterable&lt;Entry&gt; selectImports() &#123; if (this.autoConfigurationEntries.isEmpty()) &#123; return Collections.emptyList(); &#125; Set&lt;String&gt; allExclusions = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getExclusions).flatMap(Collection::stream).collect(Collectors.toSet()); Set&lt;String&gt; processedConfigurations = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getConfigurations).flatMap(Collection::stream) .collect(Collectors.toCollection(LinkedHashSet::new)); processedConfigurations.removeAll(allExclusions); return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream() .map((importClassName) -&gt; new Entry(this.entries.get(importClassName), importClassName)) .collect(Collectors.toList()); &#125; ConfigurationClassPostProcessor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); //获取容器中已经注册的BeanDefinition名称 String[] candidateNames = registry.getBeanDefinitionNames(); //检查是否是配置项 //@Configuration @Component @ComponentScan @Import @ImportResource 都是配置注解 但是区分了 full和lite模式 for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); &#125; &#125; else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) &#123; return; &#125; // 排序 // Sort by previously determined @Order value, if applicable configCandidates.sort((bd1, bd2) -&gt; &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); &#125;); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) &#123; BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) &#123; this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; &#125; if (this.environment == null) &#123; this.environment = new StandardEnvironment(); &#125; // Parse each @Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do &#123; StartupStep processConfig = this.applicationStartup.start(&quot;spring.context.config-classes.parse&quot;); // 处理该配置项 parser.parse(candidates); // 检验 parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; //将BeanDefinition注册到容器 this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); processConfig.tag(&quot;classCount&quot;, () -&gt; String.valueOf(configClasses.size())).end(); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123; String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) &#123; alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); &#125; for (String candidateName : newCandidateNames) &#123; if (!oldCandidateNames.contains(candidateName)) &#123; BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123; candidates.add(new BeanDefinitionHolder(bd, candidateName)); &#125; &#125; &#125; candidateNames = newCandidateNames; &#125; &#125; while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123; sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); &#125; if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123; // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#x27;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); &#125; &#125; parse12345678910111213141516171819202122232425262728public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123; for (BeanDefinitionHolder holder : configCandidates) &#123; BeanDefinition bd = holder.getBeanDefinition(); try &#123; if (bd instanceof AnnotatedBeanDefinition) &#123; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); &#125; else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123; parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); &#125; else &#123; parse(bd.getBeanClassName(), holder.getBeanName()); &#125; &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex); &#125; &#125; //真正处理了ImportSelector 从处理@import注解设置处理自动装配的内容 this.deferredImportSelectorHandler.process(); &#125; processConfigurationClass12345678910111213141516171819202122232425262728293031protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException &#123; if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123; return; &#125; ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) &#123; if (configClass.isImported()) &#123; if (existingClass.isImported()) &#123; existingClass.mergeImportedBy(configClass); &#125; // Otherwise ignore new imported config class; existing non-imported class overrides it. return; &#125; else &#123; // Explicit bean definition found, probably replacing an import. // Let&#x27;s remove the old one and go with the new one. this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); &#125; &#125; // Recursively process the configuration class and its superclass hierarchy. SourceClass sourceClass = asSourceClass(configClass, filter); do &#123; sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter); &#125; while (sourceClass != null); this.configurationClasses.put(configClass, configClass); &#125; doProcessConfigurationClass1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Nullable protected final SourceClass doProcessConfigurationClass( ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter) throws IOException &#123; if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123; // Recursively process any member (nested) classes first processMemberClasses(configClass, sourceClass, filter); &#125; // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; processPropertySource(propertySource); &#125; else &#123; logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); &#125; &#125; // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) &#123; bdCand = holder.getBeanDefinition(); &#125; if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123; parse(bdCand.getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), filter, true); // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) &#123; String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) &#123; String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123; this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); &#125; &#125; // No superclass -&gt; processing is complete return null; &#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot","slug":"springboot/springboot-source/springboot-source-bean","date":"2021-09-02T10:19:12.367Z","updated":"2021-09-05T04:11:10.265Z","comments":false,"path":"2021/09/02/springboot/springboot-source/springboot-source-bean/","link":"","permalink":"https://wwwwjin.github.io/2021/09/02/springboot/springboot-source/springboot-source-bean/","excerpt":"","text":"刷新上下文 refreshContext 会创建单例beanspring源码时记录","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 配置文件读取","slug":"springboot/springboot-source/springboot-source-loadconfigfile","date":"2021-09-02T08:56:30.016Z","updated":"2021-09-04T14:50:01.197Z","comments":false,"path":"2021/09/02/springboot/springboot-source/springboot-source-loadconfigfile/","link":"","permalink":"https://wwwwjin.github.io/2021/09/02/springboot/springboot-source/springboot-source-loadconfigfile/","excerpt":"","text":"追踪路径外部配置的加载发生在环境准备的通知中prepareEnvironment通知-&gt;EnvironmentPostProcessorApplicationListener -&gt;ConfigDataEnvironmentPostProcessor EnvironmentPostProcessorApplicationListener123456789private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) &#123; ConfigurableEnvironment environment = event.getEnvironment(); SpringApplication application = event.getSpringApplication(); //遍历环境后处理器 for (EnvironmentPostProcessor postProcessor : getEnvironmentPostProcessors(application.getResourceLoader(), event.getBootstrapContext())) &#123; postProcessor.postProcessEnvironment(environment, application); &#125; &#125; getEnvironmentPostProcessors123456789101112131415161718192021222324252627//获取环境后处理器List&lt;EnvironmentPostProcessor&gt; getEnvironmentPostProcessors(ResourceLoader resourceLoader, ConfigurableBootstrapContext bootstrapContext) &#123; ClassLoader classLoader = (resourceLoader != null) ? resourceLoader.getClassLoader() : null; // 获取工厂 // this.postProcessorsFactory在无参构造函数中有 // 从META-INF/spring.factories 获取EnvironmentPostProcessor接口实例 封装成ReflectionEnvironmentPostProcessorsFactory EnvironmentPostProcessorsFactory postProcessorsFactory = this.postProcessorsFactory.apply(classLoader); return postProcessorsFactory.getEnvironmentPostProcessors(this.deferredLogs, bootstrapContext); &#125;//类 ReflectionEnvironmentPostProcessorsFactory 中//通过 Instantiator 创建实例@Override public List&lt;EnvironmentPostProcessor&gt; getEnvironmentPostProcessors(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext) &#123; Instantiator&lt;EnvironmentPostProcessor&gt; instantiator = new Instantiator&lt;&gt;(EnvironmentPostProcessor.class, (parameters) -&gt; &#123; parameters.add(DeferredLogFactory.class, logFactory); parameters.add(Log.class, logFactory::getLog); parameters.add(ConfigurableBootstrapContext.class, bootstrapContext); parameters.add(BootstrapContext.class, bootstrapContext); parameters.add(BootstrapRegistry.class, bootstrapContext); &#125;); return (this.classes != null) ? instantiator.instantiateTypes(this.classes) : instantiator.instantiate(this.classLoader, this.classNames); &#125; ConfigDataEnvironmentPostProcessor多个EnvironmentPostProcessor 其中处理配置文件的是 ConfigDataEnvironmentPostProcessor 1234567891011121314void postProcessEnvironment(ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection&lt;String&gt; additionalProfiles) &#123; try &#123; this.logger.trace(&quot;Post-processing environment to add config data&quot;); resourceLoader = (resourceLoader != null) ? resourceLoader : new DefaultResourceLoader(); getConfigDataEnvironment(environment, resourceLoader, additionalProfiles).processAndApply(); &#125; catch (UseLegacyConfigProcessingException ex) &#123; this.logger.debug(LogMessage.format(&quot;Switching to legacy config file processing [%s]&quot;, ex.getConfigurationProperty())); configureAdditionalProfiles(environment, additionalProfiles); postProcessUsingLegacyApplicationListener(environment, resourceLoader); &#125; &#125; getConfigDataEnvironment12345678910111213141516171819202122232425262728ConfigDataEnvironment getConfigDataEnvironment(ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection&lt;String&gt; additionalProfiles) &#123; return new ConfigDataEnvironment(this.logFactory, this.bootstrapContext, environment, resourceLoader, additionalProfiles, this.environmentUpdateListener); &#125;ConfigDataEnvironment(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection&lt;String&gt; additionalProfiles, ConfigDataEnvironmentUpdateListener environmentUpdateListener) &#123; Binder binder = Binder.get(environment); UseLegacyConfigProcessingException.throwIfRequested(binder); this.logFactory = logFactory; this.logger = logFactory.getLog(getClass()); this.notFoundAction = binder.bind(ON_NOT_FOUND_PROPERTY, ConfigDataNotFoundAction.class) .orElse(ConfigDataNotFoundAction.FAIL); this.bootstrapContext = bootstrapContext; this.environment = environment; //从spring.factories中获取ConfigDataLocationResolver实现 this.resolvers = createConfigDataLocationResolvers(logFactory, bootstrapContext, binder, resourceLoader); this.additionalProfiles = additionalProfiles; this.environmentUpdateListener = (environmentUpdateListener != null) ? environmentUpdateListener : ConfigDataEnvironmentUpdateListener.NONE; //从spring.factories中获取所有的ConfigDataLoader并用反射进行实例化 this.loaders = new ConfigDataLoaders(logFactory, bootstrapContext, resourceLoader.getClassLoader()); //创建ConfigDataEnvironmentContributors对象，里面会根据spring.config.import / location等默认定位参数初始化Contributor this.contributors = createContributors(binder);&#125; createContributors123456789101112131415161718192021222324private ConfigDataEnvironmentContributors createContributors(Binder binder) &#123; this.logger.trace(&quot;Building config data environment contributors&quot;); MutablePropertySources propertySources = this.environment.getPropertySources(); List&lt;ConfigDataEnvironmentContributor&gt; contributors = new ArrayList&lt;&gt;(propertySources.size() + 10); PropertySource&lt;?&gt; defaultPropertySource = null; // 将已有的数据源封装成 ConfigDataEnvironmentContributor for (PropertySource&lt;?&gt; propertySource : propertySources) &#123; if (DefaultPropertiesPropertySource.hasMatchingName(propertySource)) &#123; defaultPropertySource = propertySource; &#125; else &#123; this.logger.trace(LogMessage.format(&quot;Creating wrapped config data contributor for &#x27;%s&#x27;&quot;, propertySource.getName())); contributors.add(ConfigDataEnvironmentContributor.ofExisting(propertySource)); &#125; &#125; contributors.addAll(getInitialImportContributors(binder)); if (defaultPropertySource != null) &#123; this.logger.trace(&quot;Creating wrapped config data contributor for default property source&quot;); contributors.add(ConfigDataEnvironmentContributor.ofExisting(defaultPropertySource)); &#125; //封装成ConfigDataEnvironmentContributors return createContributors(contributors); &#125; getInitialImportContributors123456789101112131415161718private List&lt;ConfigDataEnvironmentContributor&gt; getInitialImportContributors(Binder binder) &#123; List&lt;ConfigDataEnvironmentContributor&gt; initialContributors = new ArrayList&lt;&gt;(); //从环境中绑定spring.config.import，绑定失败就使用默认的 addInitialImportContributors(initialContributors, bindLocations(binder, IMPORT_PROPERTY, EMPTY_LOCATIONS)); //从环境中绑定spring.config.additional-location，绑定失败就使用默认的 addInitialImportContributors(initialContributors, bindLocations(binder, ADDITIONAL_LOCATION_PROPERTY, EMPTY_LOCATIONS)); //从环境中绑定扫描路径 // static &#123; // List&lt;ConfigDataLocation&gt; locations = new ArrayList&lt;&gt;(); // locations.add(ConfigDataLocation.of(&quot;optional:classpath:/;optional:classpath:/config/&quot;)); // locations.add(ConfigDataLocation.of(&quot;optional:file:./;optional:file:./config/;optional:file:./config/*/&quot;)); // DEFAULT_SEARCH_LOCATIONS = locations.toArray(new ConfigDataLocation[0]); // &#125; addInitialImportContributors(initialContributors, bindLocations(binder, LOCATION_PROPERTY, DEFAULT_SEARCH_LOCATIONS)); return initialContributors; &#125; processAndApply1234567891011121314151617181920void processAndApply() &#123; //封装导入对象 ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, this.notFoundAction, this.resolvers,this.loaders); //注册Binder到bootstrap实例容器 registerBootstrapBinder(this.contributors, null, DENY_INACTIVE_BINDING); //加载和解析ConfigDataLocation -&gt; ConfigDataResource -&gt; ConfigData ,此时还没有导入到Environment中，执行完毕之后应该都是BOUND_IMPORT,且此时绑定了spring.config / spring.profiles相关的配置属性信息 ConfigDataEnvironmentContributors contributors = processInitial(this.contributors, importer); //创建云平台参数 ConfigDataActivationContext activationContext = createActivationContext( contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE)); // 带入云平台参数迭代 contributors = processWithoutProfiles(contributors, importer, activationContext); //构建Profiles activationContext = withProfiles(contributors, activationContext); //带入Profiles迭代 contributors = processWithProfiles(contributors, importer, activationContext); //应用到Environment对象中 applyToEnvironment(contributors, activationContext, importer.getLoadedLocations(), importer.getOptionalLocations());&#125; processInitial1234567private ConfigDataEnvironmentContributors processInitial(ConfigDataEnvironmentContributors contributors, ConfigDataImporter importer) &#123; this.logger.trace(&quot;Processing initial config data environment contributors without activation context&quot;); contributors = contributors.withProcessedImports(importer, null); registerBootstrapBinder(contributors, null, DENY_INACTIVE_BINDING); return contributors; &#125; withProcessedImports12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ConfigDataEnvironmentContributors withProcessedImports(ConfigDataImporter importer, ConfigDataActivationContext activationContext) &#123; ImportPhase importPhase = ImportPhase.get(activationContext); this.logger.trace(LogMessage.format(&quot;Processing imports for phase %s. %s&quot;, importPhase, (activationContext != null) ? activationContext : &quot;no activation context&quot;)); ConfigDataEnvironmentContributors result = this; int processed = 0; while (true) &#123; // this.activate 对应配置文件中的 spring.config.activate.on-profile // 活跃的（this.properties == null 或者 （this.activate == null || this.activate.isActive(activationContext)）） &amp;&amp; 有未处理的imports（properties!=null 并且children没有 importPhase 键值） //简单来说就是获取需要处理的资源节点 ConfigDataEnvironmentContributor contributor = getNextToProcess(result, activationContext, importPhase); if (contributor == null) &#123; this.logger.trace(LogMessage.format(&quot;Processed imports for of %d contributors&quot;, processed)); return result; &#125; if (contributor.getKind() == Kind.UNBOUND_IMPORT) &#123; Iterable&lt;ConfigurationPropertySource&gt; sources = Collections .singleton(contributor.getConfigurationPropertySource()); PlaceholdersResolver placeholdersResolver = new ConfigDataEnvironmentContributorPlaceholdersResolver( result, activationContext, true); Binder binder = new Binder(sources, placeholdersResolver, null, null, null); //ConfigDataEnvironmentContributor 中properties属性绑定 imports与activate ConfigDataEnvironmentContributor bound = contributor.withBoundProperties(binder); //递归替换当前这个节点 result = new ConfigDataEnvironmentContributors(this.logger, this.bootstrapContext, result.getRoot().withReplacement(contributor, bound)); continue; &#125; ConfigDataLocationResolverContext locationResolverContext = new ContributorConfigDataLocationResolverContext( result, contributor, activationContext); ConfigDataLoaderContext loaderContext = new ContributorDataLoaderContext(this); List&lt;ConfigDataLocation&gt; imports = contributor.getImports(); this.logger.trace(LogMessage.format(&quot;Processing imports %s&quot;, imports)); //将配置文件解析成ConfigData Map&lt;ConfigDataResolutionResult, ConfigData&gt; imported = importer.resolveAndLoad(activationContext, locationResolverContext, loaderContext, imports); this.logger.trace(LogMessage.of(() -&gt; getImportedMessage(imported.keySet()))); //更新当前的源的子节点 ConfigDataEnvironmentContributor contributorAndChildren = contributor.withChildren(importPhase, asContributors(imported)); //获取新的root节点。递归替换新节点 result = new ConfigDataEnvironmentContributors(this.logger, this.bootstrapContext, result.getRoot().withReplacement(contributor, contributorAndChildren)); processed++; &#125;&#125; Kind123456789101112131415//Contributor的各种状态enum Kind &#123; // A root contributor used contain the initial set of children. ROOT, // An initial import that needs to be processed. INITIAL_IMPORT, // An existing property source that contributes properties but no imports. EXISTING, // A contributor with &#123;@link ConfigData&#125; imported from another contributor but not yet bound. UNBOUND_IMPORT, // A contributor with &#123;@link ConfigData&#125; imported from another contributor that has been. BOUND_IMPORT, // A valid location that contained nothing to load. EMPTY_LOCATION; &#125; ConfigDataEnvironmentContributor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class ConfigDataEnvironmentContributor implements Iterable&lt;ConfigDataEnvironmentContributor&gt; &#123; private static final ConfigData.Options EMPTY_LOCATION_OPTIONS = ConfigData.Options .of(ConfigData.Option.IGNORE_IMPORTS); private final ConfigDataLocation location; private final ConfigDataResource resource; private final boolean fromProfileSpecificImport; private final PropertySource&lt;?&gt; propertySource; private final ConfigurationPropertySource configurationPropertySource; private final ConfigDataProperties properties; private final ConfigData.Options configDataOptions; private final Map&lt;ImportPhase, List&lt;ConfigDataEnvironmentContributor&gt;&gt; children; private final Kind kind; /** * Create a new &#123;@link ConfigDataEnvironmentContributor&#125; instance. * contributor的状态 * @param kind the contributor kind * contributor的搜索路径 * @param location the location of this contributor * contributor的资源路径 * @param resource the resource that contributed the data or &#123;@code null&#125; * 是不是特殊导入 * @param fromProfileSpecificImport if the contributor is from a profile specific import * property 数据 * @param propertySource the property source for the data or &#123;@code null&#125; * 用于数据的映射 * @param configurationPropertySource the configuration property source for the data or &#123;@code null&#125; * 数据源中包含的import 和 激活状态 * @param properties the config data properties or &#123;@code null&#125; * @param configDataOptions any config data options that should apply * 子节点 * @param children the children of this contributor at each &#123;@link ImportPhase&#125; */ ConfigDataEnvironmentContributor(Kind kind, ConfigDataLocation location, ConfigDataResource resource, boolean fromProfileSpecificImport, PropertySource&lt;?&gt; propertySource, ConfigurationPropertySource configurationPropertySource, ConfigDataProperties properties, ConfigData.Options configDataOptions, Map&lt;ImportPhase, List&lt;ConfigDataEnvironmentContributor&gt;&gt; children) &#123; this.kind = kind; this.location = location; this.resource = resource; this.fromProfileSpecificImport = fromProfileSpecificImport; this.properties = properties; this.propertySource = propertySource; this.configurationPropertySource = configurationPropertySource; this.configDataOptions = (configDataOptions != null) ? configDataOptions : ConfigData.Options.NONE; this.children = (children != null) ? children : Collections.emptyMap(); &#125; /* 省略代码 */&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 事件通知","slug":"springboot/springboot-source/springboot-source-eventpublish","date":"2021-09-02T06:37:59.771Z","updated":"2021-09-02T12:38:41.420Z","comments":false,"path":"2021/09/02/springboot/springboot-source/springboot-source-eventpublish/","link":"","permalink":"https://wwwwjin.github.io/2021/09/02/springboot/springboot-source/springboot-source-eventpublish/","excerpt":"","text":"总体说明从Spring Boot 启动过程中发现事件的通知由 SpringApplicationRunListeners处理，SpringApplicationRunListeners封装了事件的监听者EventPublishingRunListener，然后由EventPublishingRunListener中的分发器 SimpleApplicationEventMulticaster 进一步将事件通知到各个监听者（SimpleApplicationEventMulticaster spring的类后面在写） SpringApplicationRunListeners12345678910111213141516171819202122232425262728class SpringApplicationRunListeners &#123; private final Log log; private final List&lt;SpringApplicationRunListener&gt; listeners; private final ApplicationStartup applicationStartup; SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners, ApplicationStartup applicationStartup) &#123; this.log = log; this.listeners = new ArrayList&lt;&gt;(listeners); this.applicationStartup = applicationStartup; &#125; /* 省略代码 */ private void doWithListeners(String stepName, Consumer&lt;SpringApplicationRunListener&gt; listenerAction, Consumer&lt;StartupStep&gt; stepAction) &#123; StartupStep step = this.applicationStartup.start(stepName); //通过SpringApplicationRunListener分发事件 this.listeners.forEach(listenerAction); if (stepAction != null) &#123; stepAction.accept(step); &#125; step.end(); &#125;&#125; EventPublishingRunListener12345678910111213141516public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123; private final SpringApplication application; private final String[] args; // 简单的事件分发器， private final SimpleApplicationEventMulticaster initialMulticaster; public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125; &#125;&#125; SpringApplicationRunListener12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public interface SpringApplicationRunListener &#123; /** * Called immediately when the run method has first started. Can be used for very * early initialization. * @param bootstrapContext the bootstrap context */ default void starting(ConfigurableBootstrapContext bootstrapContext) &#123; starting(); &#125; /** * Called immediately when the run method has first started. Can be used for very * early initialization. * @deprecated since 2.4.0 for removal in 2.6.0 in favor of * &#123;@link #starting(ConfigurableBootstrapContext)&#125; */ @Deprecated default void starting() &#123; &#125; /** * Called once the environment has been prepared, but before the * &#123;@link ApplicationContext&#125; has been created. * @param bootstrapContext the bootstrap context * @param environment the environment */ default void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123; environmentPrepared(environment); &#125; /** * Called once the environment has been prepared, but before the * &#123;@link ApplicationContext&#125; has been created. * @param environment the environment * @deprecated since 2.4.0 for removal in 2.6.0 in favor of * &#123;@link #environmentPrepared(ConfigurableBootstrapContext, ConfigurableEnvironment)&#125; */ @Deprecated default void environmentPrepared(ConfigurableEnvironment environment) &#123; &#125; /** * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but * before sources have been loaded. * @param context the application context */ default void contextPrepared(ConfigurableApplicationContext context) &#123; &#125; /** * Called once the application context has been loaded but before it has been * refreshed. * @param context the application context */ default void contextLoaded(ConfigurableApplicationContext context) &#123; &#125; /** * The context has been refreshed and the application has started but * &#123;@link CommandLineRunner CommandLineRunners&#125; and &#123;@link ApplicationRunner * ApplicationRunners&#125; have not been called. * @param context the application context. * @since 2.0.0 */ default void started(ConfigurableApplicationContext context) &#123; &#125; /** * Called immediately before the run method finishes, when the application context has * been refreshed and all &#123;@link CommandLineRunner CommandLineRunners&#125; and * &#123;@link ApplicationRunner ApplicationRunners&#125; have been called. * @param context the application context. * @since 2.0.0 */ default void running(ConfigurableApplicationContext context) &#123; &#125; /** * Called when a failure occurs when running the application. * @param context the application context or &#123;@code null&#125; if a failure occurred before * the context was created * @param exception the failure * @since 2.0.0 */ default void failed(ConfigurableApplicationContext context, Throwable exception) &#123; &#125; SpringApplicationRunListener接口定义了广播事件的不同阶段 Spring Boot个阶段的事件处理说明starting LoggingApplicationListener 获取日志系统，并做前置处理 从 META-INF/spring.factories 获取LoggingSystemFactory BackgroundPreinitializer 啥也没做 DelegatingApplicationListener 啥也没做 environmentPrepared EnvironmentPostProcessorApplicationListener 环境后处理。将配置在“spring.factories”中EnvironmentPostProcessor 接口的实现类实例化并运行其 postProcessEnvironment 方法。（在此可以自我拓展） RandomValuePropertySourceEnvironmentPostProcessor 添加random到 propertySources SystemEnvironmentPropertySourceEnvironmentPostProcessor 把systemEnvironment的对象类型从SystemEnvironmentPropertySource 换成了 SystemEnvironmentPropertySourceEnvironmentPostProcessor$OriginAwareSystemEnvironmentPropertySource SpringApplicationJsonEnvironmentPostProcessor 将名为 spring.application.json 的json解析成map存入环境中 CloudFoundryVcapEnvironmentPostProcessor 云平台相关，不明白 ConfigDataEnvironmentPostProcessor 配置文件的读取 DebugAgentEnvironmentPostProcessor 调式代理 IntegrationPropertiesEnvironmentPostProcessor 集成配置加载 AnsiOutputApplicationListener 设置输出格式。根据spring.output.ansi.enabled的值来配置AnsiOutput LoggingApplicationListener 完成日志系统配置 BackgroundPreinitializer 加快应用初始化。后台线程初始化 DelegatingApplicationListener 将应用事件广播给环境属性context.listener.classes指定的那些监听器。 FileEncodingApplicationListener contextPrepared BackgroundPreinitializer 没发生什么 DelegatingApplicationListener 没发生什么 contextLoaded EnvironmentPostProcessorApplicationListener 延迟日志写入到目的地 LoggingApplicationListener 注册日志系统，日志组到 beanFactory BackgroundPreinitializer 没发生什么 DelegatingApplicationListener 没发生什么","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 启动流程","slug":"springboot/springboot-source/springboot-source-start","date":"2021-09-02T06:26:27.461Z","updated":"2021-09-04T01:05:37.353Z","comments":false,"path":"2021/09/02/springboot/springboot-source/springboot-source-start/","link":"","permalink":"https://wwwwjin.github.io/2021/09/02/springboot/springboot-source/springboot-source-start/","excerpt":"","text":"SpringApplication构造函数1234567891011121314151617@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; //判断主要资源是否为空 Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //判断应用类型 this.webApplicationType = WebApplicationType.deduceFromClasspath(); //创建 BootstrapRegistryInitializer 接口实例 this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories(); //创建 ApplicationContextInitializer 接口实例 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //创建 ApplicationListener 接口实例 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //推断程序入口类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 推断应用类型123456789101112static WebApplicationType deduceFromClasspath() &#123; if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; for (String className : SERVLET_INDICATOR_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; return WebApplicationType.SERVLET; &#125; 根据相关类文件的存在与否推断程序类型 NONE就是什么都没有，按照正常的代码走即可不需要额外启动web容器如tomcat等；SERVLET则代表这是一个传统的servlet的web程序，对应SpringMVC，表示需要启动对应的web容器支持如tomcat等；REACTIVE则是一种比较新的非阻塞的web框架，对应spring-webflux，需要启动支持reactive的web容器 设置初始化器和监听器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123; return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;); &#125; private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; ClassLoader classLoader = getClassLoader(); //获取 META-INF/spring.factories 中实现对应 type 的类名 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //反射创建实例对象 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //根据 @Order 排序 AnnotationAwareOrderComparator.sort(instances); //返回对象 return instances; &#125;public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123; ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); &#125; private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123; // 从缓存中查找有没有当前类加载器所加载过的结果集 Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader); // 有结果则返回结果 if (result != null) &#123; return result; &#125; result = new HashMap&lt;&gt;(); try &#123; // 查找所有META-INF/spring.factories 文件 Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); // 加载文件 Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; // 获取接口类型名称 String factoryTypeName = ((String) entry.getKey()).trim(); // 实现类的名称集合 String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue()); // 将当前的实现类名放入对应的类型集合中 for (String factoryImplementationName : factoryImplementationNames) &#123; result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;()) .add(factoryImplementationName.trim()); &#125; &#125; &#125; // 对实现类名去重并返回不可修改的列表 result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct() .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList))); // 缓存这个类加载器处理加载的结果 cache.put(classLoader, result); &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); &#125; return result; &#125; BootstrapRegistryInitializer接口实例空 ApplicationContextInitializer 接口实例 实例名称 解释 DelegatingApplicationContextInitializer 加载环境中 context.initializer.classes 配置的类 SharedMetadataReaderFactoryContextInitializer 创建一个 SpringBoot 和 ConfigurationClassPostProcessor 共用的 CachingMetadataReaderFactory 对象 ContextIdApplicationContextInitializer 设置Spring应用上下文的ID ConfigurationWarningsApplicationContextInitializer 报告IOC容器的一些常见的错误配置 RSocketPortInfoApplicationContextInitializer 将RSocketServer实际使用的监听端口写入到 Environment 环境属性中 ServerPortInfoApplicationContextInitializer 将内置servlet容器实际使用的监听端口写入到 Environment 环境属性中 ConditionEvaluationReportLoggingListener 将 ConditionEvaluationReport 写入日志 ApplicationListener 接口实例 EnvironmentPostProcessorApplicationListener AnsiOutputApplicationListener LoggingApplicationListener BackgroundPreinitializer DelegatingApplicationListener ParentContextCloserApplicationListener ClearCachesApplicationListener FileEncodingApplicationListener 详见Spring Boot事件通知 推断主类1234567891011121314private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null; &#125; 从栈中推断出启动类，依据是 main 函数 SpringApplication run1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); //创建启动上下文，并执行了启动初始化(this.bootstrapRegistryInitializers) DefaultBootstrapContext bootstrapContext = createBootstrapContext(); //应用上下文 ConfigurableApplicationContext context = null; //设置系统属性 java.awt.headless 在系统可能缺少显示设备、键盘或鼠标这些外设的情况下可以使用该模式 configureHeadlessProperty(); //从 META-INF/spring.factories 中获取 //SpringApplicationRunListener 接口实例(EventPublishingRunListener)集合封装成 SpringApplicationRunListeners SpringApplicationRunListeners listeners = getRunListeners(args); //通知开始 listeners.starting(bootstrapContext, this.mainApplicationClass); try &#123; //封装应用启动参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); //用来控制是否跳过 BeanInfo 类的搜索，并且由源码可知默认值是true configureIgnoreBeanInfo(environment); //打印Banner Banner printedBanner = printBanner(environment); //创建 应用上下文 context = createApplicationContext(); //设置 ApplicationStartup context.setApplicationStartup(this.applicationStartup); //准备 应用上下文 prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); //刷新 应用上下文 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; //异常失败通知 handleRunFailure(context, ex, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, null); throw new IllegalStateException(ex); &#125; return context;&#125; createBootstrapContext123456private DefaultBootstrapContext createBootstrapContext() &#123; DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext(); //BootstrapRegistryInitializer接口实例集合依次执行 this.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext)); return bootstrapContext; &#125; configureHeadlessProperty1234private void configureHeadlessProperty() &#123; System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless))); &#125; 将java.awt.headless的值设置到了系统变量，设置成true，表示启动 java.awt.headless模式。该模式就是系统缺少了显示设备、键盘或鼠标等情况的模式，服务器一般都是在这种情况下工作的。 getRunListeners123456private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args), this.applicationStartup); &#125; 从 META-INF/spring.factories 中获取SpringApplicationRunListener接口实例封装成SpringApplicationRunListeners用于事件通知 prepareEnvironment1234567891011121314151617181920212223private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123; //根据webApplicationType返回不同的对象 ConfigurableEnvironment environment = getOrCreateEnvironment(); //把可能的命令行参数加入到环境配置中 configureEnvironment(environment, applicationArguments.getSourceArgs()); //附加 configurationProperties ConfigurationPropertySources.attach(environment); //通知环境准备好了 listeners.environmentPrepared(bootstrapContext, environment); // 改变默认配置的顺序 DefaultPropertiesPropertySource.moveToEnd(environment); Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;), &quot;Environment prefix cannot be set via properties.&quot;); bindToSpringApplication(environment); // 必要的时候转换环境 if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment;&#125; getOrCreateEnvironment12345678910111213private ConfigurableEnvironment getOrCreateEnvironment() &#123; if (this.environment != null) &#123; return this.environment; &#125; switch (this.webApplicationType) &#123; case SERVLET: return new ApplicationServletEnvironment(); case REACTIVE: return new ApplicationReactiveWebEnvironment(); default: return new ApplicationEnvironment(); &#125; &#125; 根据应用类型创建不同的应用环境 configureEnvironment1234567891011protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123; if (this.addConversionService) &#123; // 添加转换器，处理参数类型转换，如 String转Number，Integer转Enum等 environment.setConversionService(new ApplicationConversionService()); &#125; // 将启动参数添加到 environment 中 configurePropertySources(environment, args); // 处理 ActiveProfiles 值 configureProfiles(environment, args); &#125; attach12345678910111213public static void attach(Environment environment) &#123; Assert.isInstanceOf(ConfigurableEnvironment.class, environment); MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources(); PropertySource&lt;?&gt; attached = getAttached(sources); if (attached != null &amp;&amp; attached.getSource() != sources) &#123; sources.remove(ATTACHED_PROPERTY_SOURCE_NAME); attached = null; &#125; if (attached == null) &#123; sources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME, new SpringConfigurationPropertySources(sources))); &#125; &#125; configureIgnoreBeanInfo123456private void configureIgnoreBeanInfo(ConfigurableEnvironment environment) &#123; if (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) &#123; Boolean ignore = environment.getProperty(&quot;spring.beaninfo.ignore&quot;, Boolean.class, Boolean.TRUE); System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString()); &#125; &#125; 在系统属性中添加 spring.beaninfo.ignore true createApplicationContext1234567891011121314151617181920protected ConfigurableApplicationContext createApplicationContext() &#123; return this.applicationContextFactory.create(this.webApplicationType); &#125; ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123; try &#123; switch (webApplicationType) &#123; case SERVLET: return new AnnotationConfigServletWebServerApplicationContext(); case REACTIVE: return new AnnotationConfigReactiveWebServerApplicationContext(); default: return new AnnotationConfigApplicationContext(); &#125; &#125; catch (Exception ex) &#123; throw new IllegalStateException(&quot;Unable create a default ApplicationContext instance, &quot; + &quot;you may need a custom ApplicationContextFactory&quot;, ex); &#125; &#125;; 根据应用类型创建对应的上下文 prepareContext123456789101112131415161718192021222324252627282930313233343536373839private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; //设置环境 context.setEnvironment(environment); //设置一些参数 postProcessApplicationContext(context); // ApplicationContextInitializer实现类的初始化 applyInitializers(context); // 通知监听者 listeners.contextPrepared(context); // 启动上下文的关闭通知,查看了没有对应的事件处理者 bootstrapContext.close(context); // 打印信息 if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans 注册特定的启动beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.lazyInitialization) &#123; context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); &#125; // Load the sources 获取资源 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); // 注册BeanDefinition load(context, sources.toArray(new Object[0])); // 发布事件 listeners.contextLoaded(context);&#125; load12345678910111213141516171819protected void load(ApplicationContext context, Object[] sources) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources)); &#125; BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources); // this.beanNameGenerator 为null if (this.beanNameGenerator != null) &#123; loader.setBeanNameGenerator(this.beanNameGenerator); &#125; // this.resourceLoader 为null if (this.resourceLoader != null) &#123; loader.setResourceLoader(this.resourceLoader); &#125; // this.environment 为null if (this.environment != null) &#123; loader.setEnvironment(this.environment); &#125; loader.load(); &#125; load1234567891011121314151617181920212223242526272829303132333435363738394041void load() &#123; for (Object source : this.sources) &#123; load(source); &#125; &#125;private void load(Object source) &#123; Assert.notNull(source, &quot;Source must not be null&quot;); if (source instanceof Class&lt;?&gt;) &#123; load((Class&lt;?&gt;) source); return; &#125; if (source instanceof Resource) &#123; load((Resource) source); return; &#125; if (source instanceof Package) &#123; load((Package) source); return; &#125; if (source instanceof CharSequence) &#123; load((CharSequence) source); return; &#125; throw new IllegalArgumentException(&quot;Invalid source type &quot; + source.getClass()); &#125; private void load(Class&lt;?&gt; source) &#123; // Groovy相关 if (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123; // Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class); ((GroovyBeanDefinitionReader) this.groovyReader).beans(loader.getBeans()); &#125; // 检查是否有注册资格 if (isEligible(source)) &#123; // 注册bean this.annotatedReader.register(source); &#125; &#125; refreshContext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private void refreshContext(ConfigurableApplicationContext context) &#123; if (this.registerShutdownHook) &#123; //注册ShutdownHook，可以在jvm进程关闭时处理一些特定的操作。 shutdownHook.registerApplicationContext(context); &#125; refresh(context); &#125;// Spring 内容 将来换到spring 源码解读里public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;); // 准备工作 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. 告诉子类刷新bean工厂 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. 预处理加入一些bean prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. 允许子类实现对beanFactory的后置处理 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;); // Invoke factory processors registered as beans in the context. // 调用bean中的工厂处理程序 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. // 国际化 initMessageSource(); // Initialize event multicaster for this context. // 初始化事件广播器 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 启动了webServer onRefresh(); // Check for listener beans and register them. // 注册事件监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 初始化单例bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); &#125; &#125;&#125; prepareRefresh1234567891011121314151617181920212223242526272829303132333435363738protected void prepareRefresh() &#123; // Switch to active. this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Refreshing &quot; + this); &#125; else &#123; logger.debug(&quot;Refreshing &quot; + getDisplayName()); &#125; &#125; // Initialize any placeholder property sources in the context environment. // 初始化加载配置文件方法，并没有具体实现，一个留给用户的扩展点 initPropertySources(); // Validate that all properties marked as required are resolvable: // see ConfigurablePropertyResolver#setRequiredProperties // 检查环境变量 getEnvironment().validateRequiredProperties(); // Store pre-refresh ApplicationListeners... if (this.earlyApplicationListeners == null) &#123; this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); &#125; else &#123; // Reset local application listeners to pre-refresh state. this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); &#125; // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;(); &#125; prepareBeanFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context&#x27;s class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); if (!shouldIgnoreSpel) &#123; // 设置 BeanExpressionResolver——bean表达式解析器 beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); &#125; // 属性编辑器支持 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. // 这里是Spring的又一个扩展点 // 在所有实现了Aware接口的bean在初始化的时候，这个 processor负责回调， // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware // 注意：它不仅仅回调 ApplicationContextAware，还会负责回调 EnvironmentAware、ResourceLoaderAware 等 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类， // 在自动装配的时候忽略它们，Spring 会通过其他方式来处理这些依赖。 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. // 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. // 添加一个后置处理器：ApplicationListenerDetector，此后置处理器实现了BeanPostProcessor接口 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125; if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123; beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup()); &#125; &#125; postProcessBeanFactory1234567891011@Override protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // 调用父类的方法 super.postProcessBeanFactory(beanFactory); if (this.basePackages != null &amp;&amp; this.basePackages.length &gt; 0) &#123; this.scanner.scan(this.basePackages); &#125; if (!this.annotatedClasses.isEmpty()) &#123; this.reader.register(ClassUtils.toClassArray(this.annotatedClasses)); &#125; &#125; invokeBeanFactoryPostProcessors123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123; // WARNING: Although it may appear that the body of this method can be easily // refactored to avoid the use of multiple loops and multiple lists, the use // of multiple lists and multiple passes over the names of processors is // intentional. We must ensure that we honor the contracts for PriorityOrdered // and Ordered processors. Specifically, we must NOT cause processors to be // instantiated (via getBean() invocations) or registered in the ApplicationContext // in the wrong order. // // Before submitting a pull request (PR) to change this method, please review the // list of all declined PRs involving changes to PostProcessorRegistrationDelegate // to ensure that your proposal does not result in a breaking change: // https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22 // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); // 判断beanFactory是否为BeanDefinitionRegistry if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; //存放常规的BeanFactoryPostProcessor List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); //存放BeanDefinitionRegistryPostProcessor类型的 List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); // 处理入参中的beanFactoryPostProcessors for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; //执行postProcessBeanDefinitionRegistry方法 registryProcessor.postProcessBeanDefinitionRegistry(registry); //放入对应的集合 registryProcessors.add(registryProcessor); &#125; else &#123; //放入对应的集合 regularPostProcessors.add(postProcessor); &#125; &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. // 本次要执行的BeanDefinitionRegistryPostProcessor List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. // 从容器中找出实现BeanDefinitionRegistryPostProcessor接口的名称 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; // 检查是否实现了PriorityOrdered接口 if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; //创建bean currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); //执行过的名称，防止重复执行 processedBeans.add(ppName); &#125; &#125; //排序 sortPostProcessors(currentRegistryProcessors, beanFactory); //添加到 registryProcessors（用于执行postProcessBeanFactory） registryProcessors.addAll(currentRegistryProcessors); //执行postProcessBeanDefinitionRegistry方法(这里ConfigurationClassPostProcessor执行了bean的装载) invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. // 查找实现了BeanDefinitionRegistryPostProcessor的bean postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; //筛选没处理过并且继承了Ordered接口 if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; //排序 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); //执行postProcessBeanDefinitionRegistry方法 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. // 筛选剩下的 实现了BeanDefinitionRegistryPostProcessors接口的bean boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); //循环查找 reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); &#125; // Now, invoke the postProcessBeanFactory callback of all processors handled so far. // 调用所有的BeanFactoryPostProcessors方法 invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); // 调用入参里的常规的BeanFactoryPostProcessors方法 invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; else &#123; // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // 下面开始处理容器中的所有BeanFactoryPostProcessor String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // skip - already processed in first phase above &#125; else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. // 排序 sortPostProcessors(priorityOrderedPostProcessors, beanFactory); // 执行 invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. // 处理实现Ordered接口的 List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. // 处理没有继承PriorityOrdered 或者 Ordered的 List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... // 清除元数据缓存（mergedBeanDefinitions、allBeanNamesByType、singletonBeanNamesByType）， // 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符... beanFactory.clearMetadataCache(); &#125; registerBeanPostProcessors1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; // WARNING: Although it may appear that the body of this method can be easily // refactored to avoid the use of multiple loops and multiple lists, the use // of multiple lists and multiple passes over the names of processors is // intentional. We must ensure that we honor the contracts for PriorityOrdered // and Ordered processors. Specifically, we must NOT cause processors to be // instantiated (via getBean() invocations) or registered in the ApplicationContext // in the wrong order. // // Before submitting a pull request (PR) to change this method, please review the // list of all declined PRs involving changes to PostProcessorRegistrationDelegate // to ensure that your proposal does not result in a breaking change: // https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22 // 获取 容器中所有BeanPostProcessor String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); // 先获取实现了PriorityOrdered的BeanPostProcessor // 再获取实现了Ordered的BeanPostProcessor // 最后再获取不满足以上条件的BeanPostProcessor for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // Next, register the BeanPostProcessors that implement Ordered. List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String ppName : orderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // Now, register all regular BeanPostProcessors. List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String ppName : nonOrderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); &#125; finishRefresh1234567891011121314151617181920protected void finishRefresh() &#123; // Clear context-level resource caches (such as ASM metadata from scanning). clearResourceCaches(); // Initialize lifecycle processor for this context. // 初始化LifecycleProcessor initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. // 这个方法的内部实现是启动所有实现了Lifecycle接口的bean getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. if (!NativeDetector.inNativeImage()) &#123; LiveBeansView.registerApplicationContext(this); &#125; &#125; afterRefresh12protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) &#123; &#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 源码解读","slug":"springboot/springboot-source/springboot-source-overview","date":"2021-09-01T05:29:12.664Z","updated":"2021-09-04T03:07:29.353Z","comments":false,"path":"2021/09/01/springboot/springboot-source/springboot-source-overview/","link":"","permalink":"https://wwwwjin.github.io/2021/09/01/springboot/springboot-source/springboot-source-overview/","excerpt":"Spring Boot 源码解读","text":"什么是Spring Boot简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。 从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。使 用Spring Boot很容易创建一个独立运行（运行jar,内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。 流程概览图下载 SpringBootOverview.xmind 环境搭建Spring Boot 版本 2.5.3jdk 1.8helloworld的web程序 maven依赖 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 简单的Controller 12345678@RestControllerpublic class hello &#123; @GetMapping(value = &quot;/hello&quot;) public String hello()&#123; return &quot;helloworld&quot;; &#125;&#125; 程序入口 123456@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class,args); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]}